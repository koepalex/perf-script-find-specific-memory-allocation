# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2
# adopted by Alexander KÃ¶pke, Licensed under the terms of the GNU GPL License version 3

from collections import deque 
from dataclasses import dataclass

import os
import sys

sys.path.append(os.environ['PERF_EXEC_PATH'] + '/scripts/python/Perf-Trace-Util/lib/Perf/Trace')

from perf_trace_context import *
from Core import *

## >>>>>>>>>>>>>>>>>>>>>>>>>>>> CHANGE ME >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
### Add here the address of memory pages, that are you looking for ...
memory_pages_to_consider = { 0x7a77be800000, 0x7a7ea7330000, 0x7a778a000000, 0x7a778cc00000, 0x7a77a5400000, 0x7a77a2c00000 }
### or deactivate the filter by setting `memory_pages_to_consider` to **None**
#memory_pages_to_consider = None
## <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

## Data Objects to store the context from syscalls__sys_enter_* calls to use it in the
## syscalls__sys_exit_* call
@dataclass
class MMapParams:
	addr: int 
	len: int
	prot: int
	flags: int
	fd: int
	off: int

@dataclass
class MUnmapParams:
	addr: int
	len: int

@dataclass
class BrkParams:
	addr: int

@dataclass
class MRemapParams:
	addr: int
	old_len: int
	new_len: int
	flags: int
	new_addr: int

## unsure if syscalls__sys_enter_ and syscalls__sys_exit_ are always in order, better use one stack
## per sys call
mmap_stack = deque()
munmap_stack = deque()
mremap_stack = deque()
brk_stack = deque()

## syscalls callbacks
def syscalls__sys_exit_mmap(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, ret, perf_sample_dict):

		if len(mmap_stack) > 0:		
			p = mmap_stack.pop()

			if (memory_pages_to_consider is not None \
				and (ret in memory_pages_to_consider)) \
				or memory_pages_to_consider is None:

				print_header(event_name, common_cpu, common_secs, common_nsecs, common_pid, common_comm)
				print(f"Parameters: addr={p.addr:x}, len={p.len}, prot={readable_mem_page_protection(p.prot)}, flags={readable_mem_page_flags(p.flags)}, fd={p.fd:x}, off={p.off:x}".format())
				print(f"ret={ret:x}".format())
				print_callchain(common_callchain)
		else:
			print(f"Entered syscalls__sys_exit_mmap without syscalls__sys_enter_mmap first, ret={ret:x}".format())

			if (memory_pages_to_consider is not None \
				and (ret in memory_pages_to_consider)) \
				or memory_pages_to_consider is None:

				print_callchain(common_callchain)

def syscalls__sys_enter_mmap(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, addr, len, prot, 
	flags, fd, off, perf_sample_dict):
		
		p = MMapParams(addr, len, prot, flags, fd, off)
		mmap_stack.append(p)

def syscalls__sys_exit_munmap(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, ret, perf_sample_dict):
		
		if len(munmap_stack) > 0:
			p = munmap_stack.pop()

			if (memory_pages_to_consider is not None \
				and (p.addr in memory_pages_to_consider)) \
				or memory_pages_to_consider is None:

				print_header(event_name, common_cpu, common_secs, common_nsecs, common_pid, common_comm)
				print(f"Parameters: addr={p.addr:x}, len={p.len}\n".format())
				print(f"ret={ret:x}".format())
				print_callchain(common_callchain)
		else:
			print(f"Entered syscalls__sys_exit_munmap without syscalls__sys_enter_munmap first, ret={ret:x}".format())

def syscalls__sys_enter_munmap(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, addr, len, perf_sample_dict):

		p = MUnmapParams(addr, len)
		munmap_stack.append(p)

def syscalls__sys_exit_brk(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, ret, perf_sample_dict):

		if len(brk_stack) > 0:
			p = brk_stack.pop()

			if (memory_pages_to_consider is not None \
				and (p.addr in memory_pages_to_consider)) \
				or memory_pages_to_consider is None:

				print_header(event_name, common_cpu, common_secs, common_nsecs, common_pid, common_comm)
				print(f"Parameters: brk/addr={p.addr:x}\n".format())
				print(f"ret={ret:x}".format())
				print_callchain(common_callchain)
		else:
			print(f"Entered syscalls__sys_exit_brk without syscalls__sys_enter_brk first, ret={ret:x}".format())

def syscalls__sys_enter_brk(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, brk, perf_sample_dict):

		p = BrkParams(brk)
		brk_stack.append(p)

def syscalls__sys_exit_mremap(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, ret, perf_sample_dict):

		if len(mremap_stack) > 0:
			p = mremap_stack.pop()

			if (memory_pages_to_consider is not None \
				and (p.addr in memory_pages_to_consider or p.new_addr in memory_pages_to_consider)) \
				or memory_pages_to_consider is None:

				print_header(event_name, common_cpu, common_secs, common_nsecs, common_pid, common_comm)
				print(f"Parameters: addr={addr:x}, old_len={old_len}, new_len={new_len}, flags={readable_mem_page_flags(flags)}, new_addr={new_addr:x}\n".format())
				print(f"ret={ret:x}".format())
				print_callchain(common_callchain)
		else:
			print(f"Entered syscalls__sys_exit_mremap without syscalls__sys_enter_mremap first, ret={ret:x}".format())

			if (memory_pages_to_consider is not None \
				and (ret in memory_pages_to_consider)) \
				or memory_pages_to_consider is None:

				print_callchain(common_callchain)

def syscalls__sys_enter_mremap(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, __syscall_nr, addr, old_len, new_len, 
	flags, new_addr, perf_sample_dict):

		p = MRemapParams(addr, old_len, new_len, flags, new_addr)
		mremap_stack.append(p)
		
def raw_syscalls__sys_exit(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, id, ret, perf_sample_dict):
		# We handle the specific call backs and can skip this method
		pass

def raw_syscalls__sys_enter(event_name, context, common_cpu,
	common_secs, common_nsecs, common_pid, common_comm,
	common_callchain, id, args, perf_sample_dict):
		# We handle the specific call backs and can skip this method
		pass	

## lifetime events
def trace_begin():
	print("Processing perf events from script find-specific-memory-allocation.py")

def trace_end():
	print("Processing perf events finished!")

## Helper Functions
def trace_unhandled(event_name, context, event_fields_dict, perf_sample_dict):
		print(get_dict_as_string(event_fields_dict))
		print('Sample: {'+get_dict_as_string(perf_sample_dict['sample'], ', ')+'}')

def print_header(event_name, cpu, secs, nsecs, pid, comm):
	print("%-20s %5u %05u.%09u %8u %-20s " % (event_name, cpu, secs, nsecs, pid, comm))

def get_dict_as_string(a_dict, delimiter=' '):
	return delimiter.join(['%s=%s'%(k,str(v))for k,v in sorted(a_dict.items())])

def print_callchain(common_callchain):
	for node in common_callchain:
			if 'sym' in node:
				print("\t[%x] %s" % (node['ip'], node['sym']['name']))
			else:
				if 'dso' in node:
					sym = node['dso']
				else:
					sym = 'unknown'
				print("	[%x]  ([%s])" % (node['ip'],  sym))

	print()

#echo '#include <sys/mman.h>' | gcc -E - -dM | grep MAP_
def readable_mem_page_flags(flags):
	msg = ""
	if flags & 0x00 == 0x00:
		msg += "MAP_FILE|"
	if flags & 0x01 == 0x01:
		msg += "MAP_SHARED|"
	if flags & 0x02 == 0x02: 
		msg += "MAP_PRIVATE|"
	if flags & 0x03 == 0x03: 
		msg += "MAP_SHARED_VALIDATE|"
	if flags & 0x0f == 0x0f: 
		msg += "MAP_TYPE|"
	if flags & 0x10 == 0x10: 
		msg += "MAP_FIXED|"
	if flags & 0x1A == 0x1A: 
		msg += "MAP_HUGE_SHIFT|"
	if flags & 0x20 == 0x20: 
		msg += "MAP_ANONYMOUS|"
	if flags & 0x3f == 0x3f: 
		msg += "MAP_HUGE_MASK|"
	if flags & 0x40 == 0x40: 
		msg += "MAP_32BIT|"
	if flags & 0x00100 == 0x00100: 
		msg += "MAP_GROWSDOWN|"
	if flags & 0x00800 == 0x00800: 
		msg += "MAP_DENYWRITE|"
	if flags & 0x01000 == 0x01000: 
		msg += "MAP_EXECUTABLE|"
	if flags & 0x02000 == 0x02000: 
		msg += "MAP_LOCKED|"
	if flags & 0x04000 == 0x04000: 
		msg += "MAP_NORESERVE|"
	if flags & 0x08000 == 0x08000: 
		msg += "MAP_POPULATE|"
	if flags & 0x10000 == 0x10000: 
		msg += "MAP_NONBLOCK|"
	if flags & 0x20000 == 0x20000: 
		msg += "MAP_STACK|"
	if flags & 0x40000 == 0x40000: 
		msg += "MAP_HUGETLB|"
	if flags & 0x80000 == 0x80000: 
		msg += "MAP_SYNC|"
	if flags & 0x100000 == 0x100000: 
		msg += "MAP_FIXED_NOREPLACE|"
	
	if len(msg) > 0:
		msg = msg[:-1]

	return msg

#echo '#include <sys/mman.h>' | gcc -E - -dM | grep PROT_
def readable_mem_page_protection(prot):
	msg = ""
	if prot & 0x00 == 0x00:
		msg += "PROT_NONE|"
	if prot & 0x01 == 0x01:
		msg += "PROT_READ|"
	if prot & 0x02 == 0x02:
		msg += "PROT_WRITE|"
	if prot & 0x04 == 0x04:
		msg += "PROT_EXEC|"
	if prot & 0x01000000 == 0x01000000:
		msg += "PROT_GROWSDOWN|"
	if prot & 0x02000000 == 0x02000000:
		msg += "PROT_GROWSUP|"
	
	if len(msg) > 0:
		msg = msg[:-1]

	return msg